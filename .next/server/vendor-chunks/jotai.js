"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/jotai";
exports.ids = ["vendor-chunks/jotai"];
exports.modules = {

/***/ "(ssr)/./node_modules/jotai/esm/react.mjs":
/*!******************************************!*\
  !*** ./node_modules/jotai/esm/react.mjs ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Provider: () => (/* binding */ Provider),\n/* harmony export */   useAtom: () => (/* binding */ useAtom),\n/* harmony export */   useAtomValue: () => (/* binding */ useAtomValue),\n/* harmony export */   useSetAtom: () => (/* binding */ useSetAtom),\n/* harmony export */   useStore: () => (/* binding */ useStore)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var jotai_vanilla__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jotai/vanilla */ \"(ssr)/./node_modules/jotai/esm/vanilla.mjs\");\n/* __next_internal_client_entry_do_not_use__ Provider,useAtom,useAtomValue,useSetAtom,useStore auto */ \n\nconst StoreContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(void 0);\nconst useStore = (options)=>{\n    const store = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(StoreContext);\n    return (options == null ? void 0 : options.store) || store || (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_1__.getDefaultStore)();\n};\nconst Provider = ({ children, store })=>{\n    const storeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    if (!store && !storeRef.current) {\n        storeRef.current = (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_1__.createStore)();\n    }\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(StoreContext.Provider, {\n        value: store || storeRef.current\n    }, children);\n};\nconst isPromiseLike = (x)=>typeof (x == null ? void 0 : x.then) === \"function\";\nconst use = react__WEBPACK_IMPORTED_MODULE_0__.use || ((promise)=>{\n    if (promise.status === \"pending\") {\n        throw promise;\n    } else if (promise.status === \"fulfilled\") {\n        return promise.value;\n    } else if (promise.status === \"rejected\") {\n        throw promise.reason;\n    } else {\n        promise.status = \"pending\";\n        promise.then((v)=>{\n            promise.status = \"fulfilled\";\n            promise.value = v;\n        }, (e)=>{\n            promise.status = \"rejected\";\n            promise.reason = e;\n        });\n        throw promise;\n    }\n});\nfunction useAtomValue(atom, options) {\n    const store = useStore(options);\n    const [[valueFromReducer, storeFromReducer, atomFromReducer], rerender] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)((prev)=>{\n        const nextValue = store.get(atom);\n        if (Object.is(prev[0], nextValue) && prev[1] === store && prev[2] === atom) {\n            return prev;\n        }\n        return [\n            nextValue,\n            store,\n            atom\n        ];\n    }, void 0, ()=>[\n            store.get(atom),\n            store,\n            atom\n        ]);\n    let value = valueFromReducer;\n    if (storeFromReducer !== store || atomFromReducer !== atom) {\n        rerender();\n        value = store.get(atom);\n    }\n    const delay = options == null ? void 0 : options.delay;\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const unsub = store.sub(atom, ()=>{\n            if (typeof delay === \"number\") {\n                setTimeout(rerender, delay);\n                return;\n            }\n            rerender();\n        });\n        rerender();\n        return unsub;\n    }, [\n        store,\n        atom,\n        delay\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)(value);\n    return isPromiseLike(value) ? use(value) : value;\n}\nfunction useSetAtom(atom, options) {\n    const store = useStore(options);\n    const setAtom = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((...args)=>{\n        if (( false ? 0 : void 0) !== \"production\" && !(\"write\" in atom)) {\n            throw new Error(\"not writable atom\");\n        }\n        return store.set(atom, ...args);\n    }, [\n        store,\n        atom\n    ]);\n    return setAtom;\n}\nfunction useAtom(atom, options) {\n    return [\n        useAtomValue(atom, options),\n        // We do wrong type assertion here, which results in throwing an error.\n        useSetAtom(atom, options)\n    ];\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFTeUIsV0FBV2QsSUFBSSxFQUFFakIsT0FBTztJQUMvQixNQUFNQyxRQUFRRixTQUFTQztJQUN2QixNQUFNZ0MsVUFBVXJDLGtEQUFXQSxDQUN6QixDQUFDLEdBQUdzQztRQUNGLElBQUksQ0FBQyxNQUFlLEdBQUcsQ0FBb0IsR0FBRyxLQUFLLE9BQU8sZ0JBQWdCLENBQUUsWUFBV2hCLElBQUcsR0FBSTtZQUM1RixNQUFNLElBQUltQixNQUFNO1FBQ2xCO1FBQ0EsT0FBT25DLE1BQU1vQyxHQUFHLENBQUNwQixTQUFTZ0I7SUFDNUIsR0FDQTtRQUFDaEM7UUFBT2dCO0tBQUs7SUFFZixPQUFPZTtBQUNUO0FBRUEsU0FBU00sUUFBUXJCLElBQUksRUFBRWpCLE9BQU87SUFDNUIsT0FBTztRQUNMZ0IsYUFBYUMsTUFBTWpCO1FBQ25CLHVFQUF1RTtRQUN2RStCLFdBQVdkLE1BQU1qQjtLQUNsQjtBQUNIO0FBRWlFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhlcmNpc2VyLy4vbm9kZV9tb2R1bGVzL2pvdGFpL2VzbS9yZWFjdC5tanM/YWMzMiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5pbXBvcnQgUmVhY3RFeHBvcnRzLCB7IGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQsIHVzZVJlZiwgY3JlYXRlRWxlbWVudCwgdXNlUmVkdWNlciwgdXNlRWZmZWN0LCB1c2VEZWJ1Z1ZhbHVlLCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGdldERlZmF1bHRTdG9yZSwgY3JlYXRlU3RvcmUgfSBmcm9tICdqb3RhaS92YW5pbGxhJztcblxuY29uc3QgU3RvcmVDb250ZXh0ID0gY3JlYXRlQ29udGV4dChcbiAgdm9pZCAwXG4pO1xuY29uc3QgdXNlU3RvcmUgPSAob3B0aW9ucykgPT4ge1xuICBjb25zdCBzdG9yZSA9IHVzZUNvbnRleHQoU3RvcmVDb250ZXh0KTtcbiAgcmV0dXJuIChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnN0b3JlKSB8fCBzdG9yZSB8fCBnZXREZWZhdWx0U3RvcmUoKTtcbn07XG5jb25zdCBQcm92aWRlciA9ICh7XG4gIGNoaWxkcmVuLFxuICBzdG9yZVxufSkgPT4ge1xuICBjb25zdCBzdG9yZVJlZiA9IHVzZVJlZigpO1xuICBpZiAoIXN0b3JlICYmICFzdG9yZVJlZi5jdXJyZW50KSB7XG4gICAgc3RvcmVSZWYuY3VycmVudCA9IGNyZWF0ZVN0b3JlKCk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoXG4gICAgU3RvcmVDb250ZXh0LlByb3ZpZGVyLFxuICAgIHtcbiAgICAgIHZhbHVlOiBzdG9yZSB8fCBzdG9yZVJlZi5jdXJyZW50XG4gICAgfSxcbiAgICBjaGlsZHJlblxuICApO1xufTtcblxuY29uc3QgaXNQcm9taXNlTGlrZSA9ICh4KSA9PiB0eXBlb2YgKHggPT0gbnVsbCA/IHZvaWQgMCA6IHgudGhlbikgPT09IFwiZnVuY3Rpb25cIjtcbmNvbnN0IHVzZSA9IFJlYWN0RXhwb3J0cy51c2UgfHwgKChwcm9taXNlKSA9PiB7XG4gIGlmIChwcm9taXNlLnN0YXR1cyA9PT0gXCJwZW5kaW5nXCIpIHtcbiAgICB0aHJvdyBwcm9taXNlO1xuICB9IGVsc2UgaWYgKHByb21pc2Uuc3RhdHVzID09PSBcImZ1bGZpbGxlZFwiKSB7XG4gICAgcmV0dXJuIHByb21pc2UudmFsdWU7XG4gIH0gZWxzZSBpZiAocHJvbWlzZS5zdGF0dXMgPT09IFwicmVqZWN0ZWRcIikge1xuICAgIHRocm93IHByb21pc2UucmVhc29uO1xuICB9IGVsc2Uge1xuICAgIHByb21pc2Uuc3RhdHVzID0gXCJwZW5kaW5nXCI7XG4gICAgcHJvbWlzZS50aGVuKFxuICAgICAgKHYpID0+IHtcbiAgICAgICAgcHJvbWlzZS5zdGF0dXMgPSBcImZ1bGZpbGxlZFwiO1xuICAgICAgICBwcm9taXNlLnZhbHVlID0gdjtcbiAgICAgIH0sXG4gICAgICAoZSkgPT4ge1xuICAgICAgICBwcm9taXNlLnN0YXR1cyA9IFwicmVqZWN0ZWRcIjtcbiAgICAgICAgcHJvbWlzZS5yZWFzb24gPSBlO1xuICAgICAgfVxuICAgICk7XG4gICAgdGhyb3cgcHJvbWlzZTtcbiAgfVxufSk7XG5mdW5jdGlvbiB1c2VBdG9tVmFsdWUoYXRvbSwgb3B0aW9ucykge1xuICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlKG9wdGlvbnMpO1xuICBjb25zdCBbW3ZhbHVlRnJvbVJlZHVjZXIsIHN0b3JlRnJvbVJlZHVjZXIsIGF0b21Gcm9tUmVkdWNlcl0sIHJlcmVuZGVyXSA9IHVzZVJlZHVjZXIoXG4gICAgKHByZXYpID0+IHtcbiAgICAgIGNvbnN0IG5leHRWYWx1ZSA9IHN0b3JlLmdldChhdG9tKTtcbiAgICAgIGlmIChPYmplY3QuaXMocHJldlswXSwgbmV4dFZhbHVlKSAmJiBwcmV2WzFdID09PSBzdG9yZSAmJiBwcmV2WzJdID09PSBhdG9tKSB7XG4gICAgICAgIHJldHVybiBwcmV2O1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtuZXh0VmFsdWUsIHN0b3JlLCBhdG9tXTtcbiAgICB9LFxuICAgIHZvaWQgMCxcbiAgICAoKSA9PiBbc3RvcmUuZ2V0KGF0b20pLCBzdG9yZSwgYXRvbV1cbiAgKTtcbiAgbGV0IHZhbHVlID0gdmFsdWVGcm9tUmVkdWNlcjtcbiAgaWYgKHN0b3JlRnJvbVJlZHVjZXIgIT09IHN0b3JlIHx8IGF0b21Gcm9tUmVkdWNlciAhPT0gYXRvbSkge1xuICAgIHJlcmVuZGVyKCk7XG4gICAgdmFsdWUgPSBzdG9yZS5nZXQoYXRvbSk7XG4gIH1cbiAgY29uc3QgZGVsYXkgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmRlbGF5O1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHVuc3ViID0gc3RvcmUuc3ViKGF0b20sICgpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgZGVsYXkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgc2V0VGltZW91dChyZXJlbmRlciwgZGVsYXkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXJlbmRlcigpO1xuICAgIH0pO1xuICAgIHJlcmVuZGVyKCk7XG4gICAgcmV0dXJuIHVuc3ViO1xuICB9LCBbc3RvcmUsIGF0b20sIGRlbGF5XSk7XG4gIHVzZURlYnVnVmFsdWUodmFsdWUpO1xuICByZXR1cm4gaXNQcm9taXNlTGlrZSh2YWx1ZSkgPyB1c2UodmFsdWUpIDogdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHVzZVNldEF0b20oYXRvbSwgb3B0aW9ucykge1xuICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlKG9wdGlvbnMpO1xuICBjb25zdCBzZXRBdG9tID0gdXNlQ2FsbGJhY2soXG4gICAgKC4uLmFyZ3MpID0+IHtcbiAgICAgIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIiAmJiAhKFwid3JpdGVcIiBpbiBhdG9tKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub3Qgd3JpdGFibGUgYXRvbVwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdG9yZS5zZXQoYXRvbSwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBbc3RvcmUsIGF0b21dXG4gICk7XG4gIHJldHVybiBzZXRBdG9tO1xufVxuXG5mdW5jdGlvbiB1c2VBdG9tKGF0b20sIG9wdGlvbnMpIHtcbiAgcmV0dXJuIFtcbiAgICB1c2VBdG9tVmFsdWUoYXRvbSwgb3B0aW9ucyksXG4gICAgLy8gV2UgZG8gd3JvbmcgdHlwZSBhc3NlcnRpb24gaGVyZSwgd2hpY2ggcmVzdWx0cyBpbiB0aHJvd2luZyBhbiBlcnJvci5cbiAgICB1c2VTZXRBdG9tKGF0b20sIG9wdGlvbnMpXG4gIF07XG59XG5cbmV4cG9ydCB7IFByb3ZpZGVyLCB1c2VBdG9tLCB1c2VBdG9tVmFsdWUsIHVzZVNldEF0b20sIHVzZVN0b3JlIH07XG4iXSwibmFtZXMiOlsiUmVhY3RFeHBvcnRzIiwiY3JlYXRlQ29udGV4dCIsInVzZUNvbnRleHQiLCJ1c2VSZWYiLCJjcmVhdGVFbGVtZW50IiwidXNlUmVkdWNlciIsInVzZUVmZmVjdCIsInVzZURlYnVnVmFsdWUiLCJ1c2VDYWxsYmFjayIsImdldERlZmF1bHRTdG9yZSIsImNyZWF0ZVN0b3JlIiwiU3RvcmVDb250ZXh0IiwidXNlU3RvcmUiLCJvcHRpb25zIiwic3RvcmUiLCJQcm92aWRlciIsImNoaWxkcmVuIiwic3RvcmVSZWYiLCJjdXJyZW50IiwidmFsdWUiLCJpc1Byb21pc2VMaWtlIiwieCIsInRoZW4iLCJ1c2UiLCJwcm9taXNlIiwic3RhdHVzIiwicmVhc29uIiwidiIsImUiLCJ1c2VBdG9tVmFsdWUiLCJhdG9tIiwidmFsdWVGcm9tUmVkdWNlciIsInN0b3JlRnJvbVJlZHVjZXIiLCJhdG9tRnJvbVJlZHVjZXIiLCJyZXJlbmRlciIsInByZXYiLCJuZXh0VmFsdWUiLCJnZXQiLCJPYmplY3QiLCJpcyIsImRlbGF5IiwidW5zdWIiLCJzdWIiLCJzZXRUaW1lb3V0IiwidXNlU2V0QXRvbSIsInNldEF0b20iLCJhcmdzIiwiZW52IiwiTU9ERSIsIkVycm9yIiwic2V0IiwidXNlQXRvbSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jotai/esm/react.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jotai/esm/vanilla.mjs":
/*!********************************************!*\
  !*** ./node_modules/jotai/esm/vanilla.mjs ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   atom: () => (/* binding */ atom),\n/* harmony export */   createStore: () => (/* binding */ createStore),\n/* harmony export */   getDefaultStore: () => (/* binding */ getDefaultStore)\n/* harmony export */ });\nlet keyCount = 0;\nfunction atom(read, write) {\n  const key = `atom${++keyCount}`;\n  const config = {\n    toString: () => key\n  };\n  if (typeof read === \"function\") {\n    config.read = read;\n  } else {\n    config.init = read;\n    config.read = defaultRead;\n    config.write = defaultWrite;\n  }\n  if (write) {\n    config.write = write;\n  }\n  return config;\n}\nfunction defaultRead(get) {\n  return get(this);\n}\nfunction defaultWrite(get, set, arg) {\n  return set(\n    this,\n    typeof arg === \"function\" ? arg(get(this)) : arg\n  );\n}\n\nconst isSelfAtom = (atom, a) => atom.unstable_is ? atom.unstable_is(a) : a === atom;\nconst hasInitialValue = (atom) => \"init\" in atom;\nconst isActuallyWritableAtom = (atom) => !!atom.write;\nconst cancelPromiseMap = /* @__PURE__ */ new WeakMap();\nconst registerCancelPromise = (promise, cancel) => {\n  cancelPromiseMap.set(promise, cancel);\n  promise.catch(() => {\n  }).finally(() => cancelPromiseMap.delete(promise));\n};\nconst cancelPromise = (promise, next) => {\n  const cancel = cancelPromiseMap.get(promise);\n  if (cancel) {\n    cancelPromiseMap.delete(promise);\n    cancel(next);\n  }\n};\nconst resolvePromise = (promise, value) => {\n  promise.status = \"fulfilled\";\n  promise.value = value;\n};\nconst rejectPromise = (promise, e) => {\n  promise.status = \"rejected\";\n  promise.reason = e;\n};\nconst isPromiseLike = (x) => typeof (x == null ? void 0 : x.then) === \"function\";\nconst isEqualAtomValue = (a, b) => !!a && \"v\" in a && \"v\" in b && Object.is(a.v, b.v);\nconst isEqualAtomError = (a, b) => !!a && \"e\" in a && \"e\" in b && Object.is(a.e, b.e);\nconst hasPromiseAtomValue = (a) => !!a && \"v\" in a && a.v instanceof Promise;\nconst isEqualPromiseAtomValue = (a, b) => \"v\" in a && \"v\" in b && a.v.orig && a.v.orig === b.v.orig;\nconst returnAtomValue = (atomState) => {\n  if (\"e\" in atomState) {\n    throw atomState.e;\n  }\n  return atomState.v;\n};\nconst createStore$1 = () => {\n  const atomStateMap = /* @__PURE__ */ new WeakMap();\n  const mountedMap = /* @__PURE__ */ new WeakMap();\n  const pendingStack = [];\n  const pendingMap = /* @__PURE__ */ new WeakMap();\n  let devListenersRev2;\n  let mountedAtoms;\n  if (( false ? 0 : void 0) !== \"production\") {\n    devListenersRev2 = /* @__PURE__ */ new Set();\n    mountedAtoms = /* @__PURE__ */ new Set();\n  }\n  const getAtomState = (atom) => atomStateMap.get(atom);\n  const addPendingDependent = (atom, atomState) => {\n    atomState.d.forEach((_, a) => {\n      var _a;\n      if (!pendingMap.has(a)) {\n        const aState = getAtomState(a);\n        (_a = pendingStack[pendingStack.length - 1]) == null ? void 0 : _a.add(a);\n        pendingMap.set(a, [aState, /* @__PURE__ */ new Set()]);\n        if (aState) {\n          addPendingDependent(a, aState);\n        }\n      }\n      pendingMap.get(a)[1].add(atom);\n    });\n  };\n  const setAtomState = (atom, atomState) => {\n    var _a;\n    if (( false ? 0 : void 0) !== \"production\") {\n      Object.freeze(atomState);\n    }\n    const prevAtomState = getAtomState(atom);\n    atomStateMap.set(atom, atomState);\n    if (!pendingMap.has(atom)) {\n      (_a = pendingStack[pendingStack.length - 1]) == null ? void 0 : _a.add(atom);\n      pendingMap.set(atom, [prevAtomState, /* @__PURE__ */ new Set()]);\n      addPendingDependent(atom, atomState);\n    }\n    if (hasPromiseAtomValue(prevAtomState)) {\n      const next = \"v\" in atomState ? atomState.v instanceof Promise ? atomState.v : Promise.resolve(atomState.v) : Promise.reject(atomState.e);\n      if (prevAtomState.v !== next) {\n        cancelPromise(prevAtomState.v, next);\n      }\n    }\n  };\n  const updateDependencies = (atom, nextAtomState, nextDependencies, keepPreviousDependencies) => {\n    const dependencies = new Map(\n      keepPreviousDependencies ? nextAtomState.d : null\n    );\n    let changed = false;\n    nextDependencies.forEach((aState, a) => {\n      if (!aState && isSelfAtom(atom, a)) {\n        aState = nextAtomState;\n      }\n      if (aState) {\n        dependencies.set(a, aState);\n        if (nextAtomState.d.get(a) !== aState) {\n          changed = true;\n        }\n      } else if (( false ? 0 : void 0) !== \"production\") {\n        console.warn(\"[Bug] atom state not found\");\n      }\n    });\n    if (changed || nextAtomState.d.size !== dependencies.size) {\n      nextAtomState.d = dependencies;\n    }\n  };\n  const setAtomValue = (atom, value, nextDependencies, keepPreviousDependencies) => {\n    const prevAtomState = getAtomState(atom);\n    const nextAtomState = {\n      d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */ new Map(),\n      v: value\n    };\n    if (nextDependencies) {\n      updateDependencies(\n        atom,\n        nextAtomState,\n        nextDependencies,\n        keepPreviousDependencies\n      );\n    }\n    if (isEqualAtomValue(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n      return prevAtomState;\n    }\n    if (hasPromiseAtomValue(prevAtomState) && hasPromiseAtomValue(nextAtomState) && isEqualPromiseAtomValue(prevAtomState, nextAtomState)) {\n      if (prevAtomState.d === nextAtomState.d) {\n        return prevAtomState;\n      } else {\n        nextAtomState.v = prevAtomState.v;\n      }\n    }\n    setAtomState(atom, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomValueOrPromise = (atom, valueOrPromise, nextDependencies, abortPromise) => {\n    if (isPromiseLike(valueOrPromise)) {\n      let continuePromise;\n      const updatePromiseDependencies = () => {\n        const prevAtomState = getAtomState(atom);\n        if (!hasPromiseAtomValue(prevAtomState) || prevAtomState.v !== promise) {\n          return;\n        }\n        const nextAtomState = setAtomValue(\n          atom,\n          promise,\n          nextDependencies\n        );\n        if (mountedMap.has(atom) && prevAtomState.d !== nextAtomState.d) {\n          mountDependencies(atom, nextAtomState, prevAtomState.d);\n        }\n      };\n      const promise = new Promise((resolve, reject) => {\n        let settled = false;\n        valueOrPromise.then(\n          (v) => {\n            if (!settled) {\n              settled = true;\n              resolvePromise(promise, v);\n              resolve(v);\n              updatePromiseDependencies();\n            }\n          },\n          (e) => {\n            if (!settled) {\n              settled = true;\n              rejectPromise(promise, e);\n              reject(e);\n              updatePromiseDependencies();\n            }\n          }\n        );\n        continuePromise = (next) => {\n          if (!settled) {\n            settled = true;\n            next.then(\n              (v) => resolvePromise(promise, v),\n              (e) => rejectPromise(promise, e)\n            );\n            resolve(next);\n          }\n        };\n      });\n      promise.orig = valueOrPromise;\n      promise.status = \"pending\";\n      registerCancelPromise(promise, (next) => {\n        if (next) {\n          continuePromise(next);\n        }\n        abortPromise == null ? void 0 : abortPromise();\n      });\n      return setAtomValue(atom, promise, nextDependencies, true);\n    }\n    return setAtomValue(atom, valueOrPromise, nextDependencies);\n  };\n  const setAtomError = (atom, error, nextDependencies) => {\n    const prevAtomState = getAtomState(atom);\n    const nextAtomState = {\n      d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */ new Map(),\n      e: error\n    };\n    if (nextDependencies) {\n      updateDependencies(atom, nextAtomState, nextDependencies);\n    }\n    if (isEqualAtomError(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n      return prevAtomState;\n    }\n    setAtomState(atom, nextAtomState);\n    return nextAtomState;\n  };\n  const readAtomState = (atom, force) => {\n    const atomState = getAtomState(atom);\n    if (!force && atomState) {\n      if (mountedMap.has(atom)) {\n        return atomState;\n      }\n      if (Array.from(atomState.d).every(([a, s]) => {\n        if (a === atom) {\n          return true;\n        }\n        const aState = readAtomState(a);\n        return aState === s || isEqualAtomValue(aState, s);\n      })) {\n        return atomState;\n      }\n    }\n    const nextDependencies = /* @__PURE__ */ new Map();\n    let isSync = true;\n    const getter = (a) => {\n      if (isSelfAtom(atom, a)) {\n        const aState2 = getAtomState(a);\n        if (aState2) {\n          nextDependencies.set(a, aState2);\n          return returnAtomValue(aState2);\n        }\n        if (hasInitialValue(a)) {\n          nextDependencies.set(a, void 0);\n          return a.init;\n        }\n        throw new Error(\"no atom init\");\n      }\n      const aState = readAtomState(a);\n      nextDependencies.set(a, aState);\n      return returnAtomValue(aState);\n    };\n    let controller;\n    let setSelf;\n    const options = {\n      get signal() {\n        if (!controller) {\n          controller = new AbortController();\n        }\n        return controller.signal;\n      },\n      get setSelf() {\n        if (( false ? 0 : void 0) !== \"production\" && !isActuallyWritableAtom(atom)) {\n          console.warn(\"setSelf function cannot be used with read-only atom\");\n        }\n        if (!setSelf && isActuallyWritableAtom(atom)) {\n          setSelf = (...args) => {\n            if (( false ? 0 : void 0) !== \"production\" && isSync) {\n              console.warn(\"setSelf function cannot be called in sync\");\n            }\n            if (!isSync) {\n              return writeAtom(atom, ...args);\n            }\n          };\n        }\n        return setSelf;\n      }\n    };\n    try {\n      const valueOrPromise = atom.read(getter, options);\n      return setAtomValueOrPromise(\n        atom,\n        valueOrPromise,\n        nextDependencies,\n        () => controller == null ? void 0 : controller.abort()\n      );\n    } catch (error) {\n      return setAtomError(atom, error, nextDependencies);\n    } finally {\n      isSync = false;\n    }\n  };\n  const readAtom = (atom) => returnAtomValue(readAtomState(atom));\n  const recomputeDependents = (atom) => {\n    const getDependents = (a) => {\n      var _a, _b;\n      const dependents = new Set((_a = mountedMap.get(a)) == null ? void 0 : _a.t);\n      (_b = pendingMap.get(a)) == null ? void 0 : _b[1].forEach((dependent) => {\n        dependents.add(dependent);\n      });\n      return dependents;\n    };\n    const topsortedAtoms = new Array();\n    const markedAtoms = /* @__PURE__ */ new Set();\n    const visit = (n) => {\n      if (markedAtoms.has(n)) {\n        return;\n      }\n      markedAtoms.add(n);\n      for (const m of getDependents(n)) {\n        if (n !== m) {\n          visit(m);\n        }\n      }\n      topsortedAtoms.push(n);\n    };\n    visit(atom);\n    const changedAtoms = /* @__PURE__ */ new Set([atom]);\n    for (let i = topsortedAtoms.length - 1; i >= 0; --i) {\n      const a = topsortedAtoms[i];\n      const prevAtomState = getAtomState(a);\n      if (!prevAtomState) {\n        continue;\n      }\n      let hasChangedDeps = false;\n      for (const dep of prevAtomState.d.keys()) {\n        if (dep !== a && changedAtoms.has(dep)) {\n          hasChangedDeps = true;\n          break;\n        }\n      }\n      if (hasChangedDeps) {\n        const nextAtomState = readAtomState(a, true);\n        if (!isEqualAtomValue(prevAtomState, nextAtomState)) {\n          changedAtoms.add(a);\n        }\n      }\n    }\n  };\n  const writeAtomState = (atom, ...args) => {\n    const getter = (a) => returnAtomValue(readAtomState(a));\n    const setter = (a, ...args2) => {\n      const isSync = pendingStack.length > 0;\n      if (!isSync) {\n        pendingStack.push(/* @__PURE__ */ new Set([a]));\n      }\n      let r;\n      if (isSelfAtom(atom, a)) {\n        if (!hasInitialValue(a)) {\n          throw new Error(\"atom not writable\");\n        }\n        const prevAtomState = getAtomState(a);\n        const nextAtomState = setAtomValueOrPromise(a, args2[0]);\n        if (!isEqualAtomValue(prevAtomState, nextAtomState)) {\n          recomputeDependents(a);\n        }\n      } else {\n        r = writeAtomState(a, ...args2);\n      }\n      if (!isSync) {\n        const flushed = flushPending(pendingStack.pop());\n        if (( false ? 0 : void 0) !== \"production\") {\n          devListenersRev2.forEach(\n            (l) => l({ type: \"async-write\", flushed })\n          );\n        }\n      }\n      return r;\n    };\n    const result = atom.write(getter, setter, ...args);\n    return result;\n  };\n  const writeAtom = (atom, ...args) => {\n    pendingStack.push(/* @__PURE__ */ new Set([atom]));\n    const result = writeAtomState(atom, ...args);\n    const flushed = flushPending(pendingStack.pop());\n    if (( false ? 0 : void 0) !== \"production\") {\n      devListenersRev2.forEach((l) => l({ type: \"write\", flushed }));\n    }\n    return result;\n  };\n  const mountAtom = (atom, initialDependent, onMountQueue) => {\n    var _a;\n    const existingMount = mountedMap.get(atom);\n    if (existingMount) {\n      if (initialDependent) {\n        existingMount.t.add(initialDependent);\n      }\n      return existingMount;\n    }\n    const queue = onMountQueue || [];\n    (_a = getAtomState(atom)) == null ? void 0 : _a.d.forEach((_, a) => {\n      if (a !== atom) {\n        mountAtom(a, atom, queue);\n      }\n    });\n    readAtomState(atom);\n    const mounted = {\n      t: new Set(initialDependent && [initialDependent]),\n      l: /* @__PURE__ */ new Set()\n    };\n    mountedMap.set(atom, mounted);\n    if (( false ? 0 : void 0) !== \"production\") {\n      mountedAtoms.add(atom);\n    }\n    if (isActuallyWritableAtom(atom) && atom.onMount) {\n      const { onMount } = atom;\n      queue.push(() => {\n        const onUnmount = onMount((...args) => writeAtom(atom, ...args));\n        if (onUnmount) {\n          mounted.u = onUnmount;\n        }\n      });\n    }\n    if (!onMountQueue) {\n      queue.forEach((f) => f());\n    }\n    return mounted;\n  };\n  const canUnmountAtom = (atom, mounted) => !mounted.l.size && (!mounted.t.size || mounted.t.size === 1 && mounted.t.has(atom));\n  const tryUnmountAtom = (atom, mounted) => {\n    if (!canUnmountAtom(atom, mounted)) {\n      return;\n    }\n    const onUnmount = mounted.u;\n    if (onUnmount) {\n      onUnmount();\n    }\n    mountedMap.delete(atom);\n    if (( false ? 0 : void 0) !== \"production\") {\n      mountedAtoms.delete(atom);\n    }\n    const atomState = getAtomState(atom);\n    if (atomState) {\n      if (hasPromiseAtomValue(atomState)) {\n        cancelPromise(atomState.v);\n      }\n      atomState.d.forEach((_, a) => {\n        if (a !== atom) {\n          const mountedDep = mountedMap.get(a);\n          if (mountedDep) {\n            mountedDep.t.delete(atom);\n            tryUnmountAtom(a, mountedDep);\n          }\n        }\n      });\n    } else if (( false ? 0 : void 0) !== \"production\") {\n      console.warn(\"[Bug] could not find atom state to unmount\", atom);\n    }\n  };\n  const mountDependencies = (atom, atomState, prevDependencies) => {\n    const depSet = new Set(atomState.d.keys());\n    const maybeUnmountAtomSet = /* @__PURE__ */ new Set();\n    prevDependencies == null ? void 0 : prevDependencies.forEach((_, a) => {\n      if (depSet.has(a)) {\n        depSet.delete(a);\n        return;\n      }\n      maybeUnmountAtomSet.add(a);\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.delete(atom);\n      }\n    });\n    depSet.forEach((a) => {\n      mountAtom(a, atom);\n    });\n    maybeUnmountAtomSet.forEach((a) => {\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        tryUnmountAtom(a, mounted);\n      }\n    });\n  };\n  const flushPending = (pendingAtoms) => {\n    let flushed;\n    if (( false ? 0 : void 0) !== \"production\") {\n      flushed = /* @__PURE__ */ new Set();\n    }\n    const pending = [];\n    const collectPending = (pendingAtom) => {\n      var _a;\n      if (!pendingMap.has(pendingAtom)) {\n        return;\n      }\n      const [prevAtomState, dependents] = pendingMap.get(pendingAtom);\n      pendingMap.delete(pendingAtom);\n      pending.push([pendingAtom, prevAtomState]);\n      dependents.forEach(collectPending);\n      (_a = getAtomState(pendingAtom)) == null ? void 0 : _a.d.forEach((_, a) => collectPending(a));\n    };\n    pendingAtoms.forEach(collectPending);\n    pending.forEach(([atom, prevAtomState]) => {\n      const atomState = getAtomState(atom);\n      if (!atomState) {\n        if (( false ? 0 : void 0) !== \"production\") {\n          console.warn(\"[Bug] no atom state to flush\");\n        }\n        return;\n      }\n      if (atomState !== prevAtomState) {\n        const mounted = mountedMap.get(atom);\n        if (mounted && atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n          mountDependencies(atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n        }\n        if (mounted && !// TODO This seems pretty hacky. Hope to fix it.\n        // Maybe we could `mountDependencies` in `setAtomState`?\n        (!hasPromiseAtomValue(prevAtomState) && (isEqualAtomValue(prevAtomState, atomState) || isEqualAtomError(prevAtomState, atomState)))) {\n          mounted.l.forEach((listener) => listener());\n          if (( false ? 0 : void 0) !== \"production\") {\n            flushed.add(atom);\n          }\n        }\n      }\n    });\n    if (( false ? 0 : void 0) !== \"production\") {\n      return flushed;\n    }\n  };\n  const subscribeAtom = (atom, listener) => {\n    const mounted = mountAtom(atom);\n    const flushed = flushPending([atom]);\n    const listeners = mounted.l;\n    listeners.add(listener);\n    if (( false ? 0 : void 0) !== \"production\") {\n      devListenersRev2.forEach(\n        (l) => l({ type: \"sub\", flushed })\n      );\n    }\n    return () => {\n      listeners.delete(listener);\n      tryUnmountAtom(atom, mounted);\n      if (( false ? 0 : void 0) !== \"production\") {\n        devListenersRev2.forEach((l) => l({ type: \"unsub\" }));\n      }\n    };\n  };\n  if (( false ? 0 : void 0) !== \"production\") {\n    return {\n      get: readAtom,\n      set: writeAtom,\n      sub: subscribeAtom,\n      // store dev methods (these are tentative and subject to change without notice)\n      dev_subscribe_store: (l) => {\n        devListenersRev2.add(l);\n        return () => {\n          devListenersRev2.delete(l);\n        };\n      },\n      dev_get_mounted_atoms: () => mountedAtoms.values(),\n      dev_get_atom_state: (a) => atomStateMap.get(a),\n      dev_get_mounted: (a) => mountedMap.get(a),\n      dev_restore_atoms: (values) => {\n        pendingStack.push(/* @__PURE__ */ new Set());\n        for (const [atom, valueOrPromise] of values) {\n          if (hasInitialValue(atom)) {\n            setAtomValueOrPromise(atom, valueOrPromise);\n            recomputeDependents(atom);\n          }\n        }\n        const flushed = flushPending(pendingStack.pop());\n        devListenersRev2.forEach(\n          (l) => l({ type: \"restore\", flushed })\n        );\n      }\n    };\n  }\n  return {\n    get: readAtom,\n    set: writeAtom,\n    sub: subscribeAtom\n  };\n};\nlet defaultStore;\nconst getDefaultStore$1 = () => {\n  if (!defaultStore) {\n    defaultStore = createStore$1();\n    if (( false ? 0 : void 0) !== \"production\") {\n      globalThis.__JOTAI_DEFAULT_STORE__ || (globalThis.__JOTAI_DEFAULT_STORE__ = defaultStore);\n      if (globalThis.__JOTAI_DEFAULT_STORE__ !== defaultStore) {\n        console.warn(\n          \"Detected multiple Jotai instances. It may cause unexpected behavior with the default store. https://github.com/pmndrs/jotai/discussions/2044\"\n        );\n      }\n    }\n  }\n  return defaultStore;\n};\n\nSymbol(\n  ( false ? 0 : void 0) !== \"production\" ? \"CONTINUE_PROMISE\" : \"\"\n);\n\nconst createStore = createStore$1;\nconst getDefaultStore = getDefaultStore$1;\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam90YWkvZXNtL3ZhbmlsbGEubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQSxxQkFBcUIsV0FBVztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sTUFBZSxHQUFHLENBQW9CO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVMsTUFBZSxHQUFHLENBQW9CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsVUFBVSxNQUFlLEdBQUcsQ0FBb0I7QUFDeEQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLGFBQWEsTUFBZSxHQUFHLENBQW9CO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE1BQWUsR0FBRyxDQUFvQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLE1BQWUsR0FBRyxDQUFvQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUcsTUFBZSxHQUFHLENBQW9CO0FBQ3pDOztBQUVBO0FBQ0E7O0FBRThDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhlcmNpc2VyLy4vbm9kZV9tb2R1bGVzL2pvdGFpL2VzbS92YW5pbGxhLm1qcz83NWY1Il0sInNvdXJjZXNDb250ZW50IjpbImxldCBrZXlDb3VudCA9IDA7XG5mdW5jdGlvbiBhdG9tKHJlYWQsIHdyaXRlKSB7XG4gIGNvbnN0IGtleSA9IGBhdG9tJHsrK2tleUNvdW50fWA7XG4gIGNvbnN0IGNvbmZpZyA9IHtcbiAgICB0b1N0cmluZzogKCkgPT4ga2V5XG4gIH07XG4gIGlmICh0eXBlb2YgcmVhZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgY29uZmlnLnJlYWQgPSByZWFkO1xuICB9IGVsc2Uge1xuICAgIGNvbmZpZy5pbml0ID0gcmVhZDtcbiAgICBjb25maWcucmVhZCA9IGRlZmF1bHRSZWFkO1xuICAgIGNvbmZpZy53cml0ZSA9IGRlZmF1bHRXcml0ZTtcbiAgfVxuICBpZiAod3JpdGUpIHtcbiAgICBjb25maWcud3JpdGUgPSB3cml0ZTtcbiAgfVxuICByZXR1cm4gY29uZmlnO1xufVxuZnVuY3Rpb24gZGVmYXVsdFJlYWQoZ2V0KSB7XG4gIHJldHVybiBnZXQodGhpcyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0V3JpdGUoZ2V0LCBzZXQsIGFyZykge1xuICByZXR1cm4gc2V0KFxuICAgIHRoaXMsXG4gICAgdHlwZW9mIGFyZyA9PT0gXCJmdW5jdGlvblwiID8gYXJnKGdldCh0aGlzKSkgOiBhcmdcbiAgKTtcbn1cblxuY29uc3QgaXNTZWxmQXRvbSA9IChhdG9tLCBhKSA9PiBhdG9tLnVuc3RhYmxlX2lzID8gYXRvbS51bnN0YWJsZV9pcyhhKSA6IGEgPT09IGF0b207XG5jb25zdCBoYXNJbml0aWFsVmFsdWUgPSAoYXRvbSkgPT4gXCJpbml0XCIgaW4gYXRvbTtcbmNvbnN0IGlzQWN0dWFsbHlXcml0YWJsZUF0b20gPSAoYXRvbSkgPT4gISFhdG9tLndyaXRlO1xuY29uc3QgY2FuY2VsUHJvbWlzZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuY29uc3QgcmVnaXN0ZXJDYW5jZWxQcm9taXNlID0gKHByb21pc2UsIGNhbmNlbCkgPT4ge1xuICBjYW5jZWxQcm9taXNlTWFwLnNldChwcm9taXNlLCBjYW5jZWwpO1xuICBwcm9taXNlLmNhdGNoKCgpID0+IHtcbiAgfSkuZmluYWxseSgoKSA9PiBjYW5jZWxQcm9taXNlTWFwLmRlbGV0ZShwcm9taXNlKSk7XG59O1xuY29uc3QgY2FuY2VsUHJvbWlzZSA9IChwcm9taXNlLCBuZXh0KSA9PiB7XG4gIGNvbnN0IGNhbmNlbCA9IGNhbmNlbFByb21pc2VNYXAuZ2V0KHByb21pc2UpO1xuICBpZiAoY2FuY2VsKSB7XG4gICAgY2FuY2VsUHJvbWlzZU1hcC5kZWxldGUocHJvbWlzZSk7XG4gICAgY2FuY2VsKG5leHQpO1xuICB9XG59O1xuY29uc3QgcmVzb2x2ZVByb21pc2UgPSAocHJvbWlzZSwgdmFsdWUpID0+IHtcbiAgcHJvbWlzZS5zdGF0dXMgPSBcImZ1bGZpbGxlZFwiO1xuICBwcm9taXNlLnZhbHVlID0gdmFsdWU7XG59O1xuY29uc3QgcmVqZWN0UHJvbWlzZSA9IChwcm9taXNlLCBlKSA9PiB7XG4gIHByb21pc2Uuc3RhdHVzID0gXCJyZWplY3RlZFwiO1xuICBwcm9taXNlLnJlYXNvbiA9IGU7XG59O1xuY29uc3QgaXNQcm9taXNlTGlrZSA9ICh4KSA9PiB0eXBlb2YgKHggPT0gbnVsbCA/IHZvaWQgMCA6IHgudGhlbikgPT09IFwiZnVuY3Rpb25cIjtcbmNvbnN0IGlzRXF1YWxBdG9tVmFsdWUgPSAoYSwgYikgPT4gISFhICYmIFwidlwiIGluIGEgJiYgXCJ2XCIgaW4gYiAmJiBPYmplY3QuaXMoYS52LCBiLnYpO1xuY29uc3QgaXNFcXVhbEF0b21FcnJvciA9IChhLCBiKSA9PiAhIWEgJiYgXCJlXCIgaW4gYSAmJiBcImVcIiBpbiBiICYmIE9iamVjdC5pcyhhLmUsIGIuZSk7XG5jb25zdCBoYXNQcm9taXNlQXRvbVZhbHVlID0gKGEpID0+ICEhYSAmJiBcInZcIiBpbiBhICYmIGEudiBpbnN0YW5jZW9mIFByb21pc2U7XG5jb25zdCBpc0VxdWFsUHJvbWlzZUF0b21WYWx1ZSA9IChhLCBiKSA9PiBcInZcIiBpbiBhICYmIFwidlwiIGluIGIgJiYgYS52Lm9yaWcgJiYgYS52Lm9yaWcgPT09IGIudi5vcmlnO1xuY29uc3QgcmV0dXJuQXRvbVZhbHVlID0gKGF0b21TdGF0ZSkgPT4ge1xuICBpZiAoXCJlXCIgaW4gYXRvbVN0YXRlKSB7XG4gICAgdGhyb3cgYXRvbVN0YXRlLmU7XG4gIH1cbiAgcmV0dXJuIGF0b21TdGF0ZS52O1xufTtcbmNvbnN0IGNyZWF0ZVN0b3JlJDEgPSAoKSA9PiB7XG4gIGNvbnN0IGF0b21TdGF0ZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICBjb25zdCBtb3VudGVkTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gIGNvbnN0IHBlbmRpbmdTdGFjayA9IFtdO1xuICBjb25zdCBwZW5kaW5nTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gIGxldCBkZXZMaXN0ZW5lcnNSZXYyO1xuICBsZXQgbW91bnRlZEF0b21zO1xuICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBkZXZMaXN0ZW5lcnNSZXYyID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBtb3VudGVkQXRvbXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICB9XG4gIGNvbnN0IGdldEF0b21TdGF0ZSA9IChhdG9tKSA9PiBhdG9tU3RhdGVNYXAuZ2V0KGF0b20pO1xuICBjb25zdCBhZGRQZW5kaW5nRGVwZW5kZW50ID0gKGF0b20sIGF0b21TdGF0ZSkgPT4ge1xuICAgIGF0b21TdGF0ZS5kLmZvckVhY2goKF8sIGEpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGlmICghcGVuZGluZ01hcC5oYXMoYSkpIHtcbiAgICAgICAgY29uc3QgYVN0YXRlID0gZ2V0QXRvbVN0YXRlKGEpO1xuICAgICAgICAoX2EgPSBwZW5kaW5nU3RhY2tbcGVuZGluZ1N0YWNrLmxlbmd0aCAtIDFdKSA9PSBudWxsID8gdm9pZCAwIDogX2EuYWRkKGEpO1xuICAgICAgICBwZW5kaW5nTWFwLnNldChhLCBbYVN0YXRlLCAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpXSk7XG4gICAgICAgIGlmIChhU3RhdGUpIHtcbiAgICAgICAgICBhZGRQZW5kaW5nRGVwZW5kZW50KGEsIGFTdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHBlbmRpbmdNYXAuZ2V0KGEpWzFdLmFkZChhdG9tKTtcbiAgICB9KTtcbiAgfTtcbiAgY29uc3Qgc2V0QXRvbVN0YXRlID0gKGF0b20sIGF0b21TdGF0ZSkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIE9iamVjdC5mcmVlemUoYXRvbVN0YXRlKTtcbiAgICB9XG4gICAgY29uc3QgcHJldkF0b21TdGF0ZSA9IGdldEF0b21TdGF0ZShhdG9tKTtcbiAgICBhdG9tU3RhdGVNYXAuc2V0KGF0b20sIGF0b21TdGF0ZSk7XG4gICAgaWYgKCFwZW5kaW5nTWFwLmhhcyhhdG9tKSkge1xuICAgICAgKF9hID0gcGVuZGluZ1N0YWNrW3BlbmRpbmdTdGFjay5sZW5ndGggLSAxXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmFkZChhdG9tKTtcbiAgICAgIHBlbmRpbmdNYXAuc2V0KGF0b20sIFtwcmV2QXRvbVN0YXRlLCAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpXSk7XG4gICAgICBhZGRQZW5kaW5nRGVwZW5kZW50KGF0b20sIGF0b21TdGF0ZSk7XG4gICAgfVxuICAgIGlmIChoYXNQcm9taXNlQXRvbVZhbHVlKHByZXZBdG9tU3RhdGUpKSB7XG4gICAgICBjb25zdCBuZXh0ID0gXCJ2XCIgaW4gYXRvbVN0YXRlID8gYXRvbVN0YXRlLnYgaW5zdGFuY2VvZiBQcm9taXNlID8gYXRvbVN0YXRlLnYgOiBQcm9taXNlLnJlc29sdmUoYXRvbVN0YXRlLnYpIDogUHJvbWlzZS5yZWplY3QoYXRvbVN0YXRlLmUpO1xuICAgICAgaWYgKHByZXZBdG9tU3RhdGUudiAhPT0gbmV4dCkge1xuICAgICAgICBjYW5jZWxQcm9taXNlKHByZXZBdG9tU3RhdGUudiwgbmV4dCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCB1cGRhdGVEZXBlbmRlbmNpZXMgPSAoYXRvbSwgbmV4dEF0b21TdGF0ZSwgbmV4dERlcGVuZGVuY2llcywga2VlcFByZXZpb3VzRGVwZW5kZW5jaWVzKSA9PiB7XG4gICAgY29uc3QgZGVwZW5kZW5jaWVzID0gbmV3IE1hcChcbiAgICAgIGtlZXBQcmV2aW91c0RlcGVuZGVuY2llcyA/IG5leHRBdG9tU3RhdGUuZCA6IG51bGxcbiAgICApO1xuICAgIGxldCBjaGFuZ2VkID0gZmFsc2U7XG4gICAgbmV4dERlcGVuZGVuY2llcy5mb3JFYWNoKChhU3RhdGUsIGEpID0+IHtcbiAgICAgIGlmICghYVN0YXRlICYmIGlzU2VsZkF0b20oYXRvbSwgYSkpIHtcbiAgICAgICAgYVN0YXRlID0gbmV4dEF0b21TdGF0ZTtcbiAgICAgIH1cbiAgICAgIGlmIChhU3RhdGUpIHtcbiAgICAgICAgZGVwZW5kZW5jaWVzLnNldChhLCBhU3RhdGUpO1xuICAgICAgICBpZiAobmV4dEF0b21TdGF0ZS5kLmdldChhKSAhPT0gYVN0YXRlKSB7XG4gICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiW0J1Z10gYXRvbSBzdGF0ZSBub3QgZm91bmRcIik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKGNoYW5nZWQgfHwgbmV4dEF0b21TdGF0ZS5kLnNpemUgIT09IGRlcGVuZGVuY2llcy5zaXplKSB7XG4gICAgICBuZXh0QXRvbVN0YXRlLmQgPSBkZXBlbmRlbmNpZXM7XG4gICAgfVxuICB9O1xuICBjb25zdCBzZXRBdG9tVmFsdWUgPSAoYXRvbSwgdmFsdWUsIG5leHREZXBlbmRlbmNpZXMsIGtlZXBQcmV2aW91c0RlcGVuZGVuY2llcykgPT4ge1xuICAgIGNvbnN0IHByZXZBdG9tU3RhdGUgPSBnZXRBdG9tU3RhdGUoYXRvbSk7XG4gICAgY29uc3QgbmV4dEF0b21TdGF0ZSA9IHtcbiAgICAgIGQ6IChwcmV2QXRvbVN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBwcmV2QXRvbVN0YXRlLmQpIHx8IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgICB2OiB2YWx1ZVxuICAgIH07XG4gICAgaWYgKG5leHREZXBlbmRlbmNpZXMpIHtcbiAgICAgIHVwZGF0ZURlcGVuZGVuY2llcyhcbiAgICAgICAgYXRvbSxcbiAgICAgICAgbmV4dEF0b21TdGF0ZSxcbiAgICAgICAgbmV4dERlcGVuZGVuY2llcyxcbiAgICAgICAga2VlcFByZXZpb3VzRGVwZW5kZW5jaWVzXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoaXNFcXVhbEF0b21WYWx1ZShwcmV2QXRvbVN0YXRlLCBuZXh0QXRvbVN0YXRlKSAmJiBwcmV2QXRvbVN0YXRlLmQgPT09IG5leHRBdG9tU3RhdGUuZCkge1xuICAgICAgcmV0dXJuIHByZXZBdG9tU3RhdGU7XG4gICAgfVxuICAgIGlmIChoYXNQcm9taXNlQXRvbVZhbHVlKHByZXZBdG9tU3RhdGUpICYmIGhhc1Byb21pc2VBdG9tVmFsdWUobmV4dEF0b21TdGF0ZSkgJiYgaXNFcXVhbFByb21pc2VBdG9tVmFsdWUocHJldkF0b21TdGF0ZSwgbmV4dEF0b21TdGF0ZSkpIHtcbiAgICAgIGlmIChwcmV2QXRvbVN0YXRlLmQgPT09IG5leHRBdG9tU3RhdGUuZCkge1xuICAgICAgICByZXR1cm4gcHJldkF0b21TdGF0ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRBdG9tU3RhdGUudiA9IHByZXZBdG9tU3RhdGUudjtcbiAgICAgIH1cbiAgICB9XG4gICAgc2V0QXRvbVN0YXRlKGF0b20sIG5leHRBdG9tU3RhdGUpO1xuICAgIHJldHVybiBuZXh0QXRvbVN0YXRlO1xuICB9O1xuICBjb25zdCBzZXRBdG9tVmFsdWVPclByb21pc2UgPSAoYXRvbSwgdmFsdWVPclByb21pc2UsIG5leHREZXBlbmRlbmNpZXMsIGFib3J0UHJvbWlzZSkgPT4ge1xuICAgIGlmIChpc1Byb21pc2VMaWtlKHZhbHVlT3JQcm9taXNlKSkge1xuICAgICAgbGV0IGNvbnRpbnVlUHJvbWlzZTtcbiAgICAgIGNvbnN0IHVwZGF0ZVByb21pc2VEZXBlbmRlbmNpZXMgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHByZXZBdG9tU3RhdGUgPSBnZXRBdG9tU3RhdGUoYXRvbSk7XG4gICAgICAgIGlmICghaGFzUHJvbWlzZUF0b21WYWx1ZShwcmV2QXRvbVN0YXRlKSB8fCBwcmV2QXRvbVN0YXRlLnYgIT09IHByb21pc2UpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV4dEF0b21TdGF0ZSA9IHNldEF0b21WYWx1ZShcbiAgICAgICAgICBhdG9tLFxuICAgICAgICAgIHByb21pc2UsXG4gICAgICAgICAgbmV4dERlcGVuZGVuY2llc1xuICAgICAgICApO1xuICAgICAgICBpZiAobW91bnRlZE1hcC5oYXMoYXRvbSkgJiYgcHJldkF0b21TdGF0ZS5kICE9PSBuZXh0QXRvbVN0YXRlLmQpIHtcbiAgICAgICAgICBtb3VudERlcGVuZGVuY2llcyhhdG9tLCBuZXh0QXRvbVN0YXRlLCBwcmV2QXRvbVN0YXRlLmQpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgbGV0IHNldHRsZWQgPSBmYWxzZTtcbiAgICAgICAgdmFsdWVPclByb21pc2UudGhlbihcbiAgICAgICAgICAodikgPT4ge1xuICAgICAgICAgICAgaWYgKCFzZXR0bGVkKSB7XG4gICAgICAgICAgICAgIHNldHRsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICByZXNvbHZlUHJvbWlzZShwcm9taXNlLCB2KTtcbiAgICAgICAgICAgICAgcmVzb2x2ZSh2KTtcbiAgICAgICAgICAgICAgdXBkYXRlUHJvbWlzZURlcGVuZGVuY2llcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgKGUpID0+IHtcbiAgICAgICAgICAgIGlmICghc2V0dGxlZCkge1xuICAgICAgICAgICAgICBzZXR0bGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgcmVqZWN0UHJvbWlzZShwcm9taXNlLCBlKTtcbiAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICB1cGRhdGVQcm9taXNlRGVwZW5kZW5jaWVzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgICBjb250aW51ZVByb21pc2UgPSAobmV4dCkgPT4ge1xuICAgICAgICAgIGlmICghc2V0dGxlZCkge1xuICAgICAgICAgICAgc2V0dGxlZCA9IHRydWU7XG4gICAgICAgICAgICBuZXh0LnRoZW4oXG4gICAgICAgICAgICAgICh2KSA9PiByZXNvbHZlUHJvbWlzZShwcm9taXNlLCB2KSxcbiAgICAgICAgICAgICAgKGUpID0+IHJlamVjdFByb21pc2UocHJvbWlzZSwgZSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXNvbHZlKG5leHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgcHJvbWlzZS5vcmlnID0gdmFsdWVPclByb21pc2U7XG4gICAgICBwcm9taXNlLnN0YXR1cyA9IFwicGVuZGluZ1wiO1xuICAgICAgcmVnaXN0ZXJDYW5jZWxQcm9taXNlKHByb21pc2UsIChuZXh0KSA9PiB7XG4gICAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgICAgY29udGludWVQcm9taXNlKG5leHQpO1xuICAgICAgICB9XG4gICAgICAgIGFib3J0UHJvbWlzZSA9PSBudWxsID8gdm9pZCAwIDogYWJvcnRQcm9taXNlKCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBzZXRBdG9tVmFsdWUoYXRvbSwgcHJvbWlzZSwgbmV4dERlcGVuZGVuY2llcywgdHJ1ZSk7XG4gICAgfVxuICAgIHJldHVybiBzZXRBdG9tVmFsdWUoYXRvbSwgdmFsdWVPclByb21pc2UsIG5leHREZXBlbmRlbmNpZXMpO1xuICB9O1xuICBjb25zdCBzZXRBdG9tRXJyb3IgPSAoYXRvbSwgZXJyb3IsIG5leHREZXBlbmRlbmNpZXMpID0+IHtcbiAgICBjb25zdCBwcmV2QXRvbVN0YXRlID0gZ2V0QXRvbVN0YXRlKGF0b20pO1xuICAgIGNvbnN0IG5leHRBdG9tU3RhdGUgPSB7XG4gICAgICBkOiAocHJldkF0b21TdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogcHJldkF0b21TdGF0ZS5kKSB8fCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAgICAgZTogZXJyb3JcbiAgICB9O1xuICAgIGlmIChuZXh0RGVwZW5kZW5jaWVzKSB7XG4gICAgICB1cGRhdGVEZXBlbmRlbmNpZXMoYXRvbSwgbmV4dEF0b21TdGF0ZSwgbmV4dERlcGVuZGVuY2llcyk7XG4gICAgfVxuICAgIGlmIChpc0VxdWFsQXRvbUVycm9yKHByZXZBdG9tU3RhdGUsIG5leHRBdG9tU3RhdGUpICYmIHByZXZBdG9tU3RhdGUuZCA9PT0gbmV4dEF0b21TdGF0ZS5kKSB7XG4gICAgICByZXR1cm4gcHJldkF0b21TdGF0ZTtcbiAgICB9XG4gICAgc2V0QXRvbVN0YXRlKGF0b20sIG5leHRBdG9tU3RhdGUpO1xuICAgIHJldHVybiBuZXh0QXRvbVN0YXRlO1xuICB9O1xuICBjb25zdCByZWFkQXRvbVN0YXRlID0gKGF0b20sIGZvcmNlKSA9PiB7XG4gICAgY29uc3QgYXRvbVN0YXRlID0gZ2V0QXRvbVN0YXRlKGF0b20pO1xuICAgIGlmICghZm9yY2UgJiYgYXRvbVN0YXRlKSB7XG4gICAgICBpZiAobW91bnRlZE1hcC5oYXMoYXRvbSkpIHtcbiAgICAgICAgcmV0dXJuIGF0b21TdGF0ZTtcbiAgICAgIH1cbiAgICAgIGlmIChBcnJheS5mcm9tKGF0b21TdGF0ZS5kKS5ldmVyeSgoW2EsIHNdKSA9PiB7XG4gICAgICAgIGlmIChhID09PSBhdG9tKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYVN0YXRlID0gcmVhZEF0b21TdGF0ZShhKTtcbiAgICAgICAgcmV0dXJuIGFTdGF0ZSA9PT0gcyB8fCBpc0VxdWFsQXRvbVZhbHVlKGFTdGF0ZSwgcyk7XG4gICAgICB9KSkge1xuICAgICAgICByZXR1cm4gYXRvbVN0YXRlO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBuZXh0RGVwZW5kZW5jaWVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBsZXQgaXNTeW5jID0gdHJ1ZTtcbiAgICBjb25zdCBnZXR0ZXIgPSAoYSkgPT4ge1xuICAgICAgaWYgKGlzU2VsZkF0b20oYXRvbSwgYSkpIHtcbiAgICAgICAgY29uc3QgYVN0YXRlMiA9IGdldEF0b21TdGF0ZShhKTtcbiAgICAgICAgaWYgKGFTdGF0ZTIpIHtcbiAgICAgICAgICBuZXh0RGVwZW5kZW5jaWVzLnNldChhLCBhU3RhdGUyKTtcbiAgICAgICAgICByZXR1cm4gcmV0dXJuQXRvbVZhbHVlKGFTdGF0ZTIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNJbml0aWFsVmFsdWUoYSkpIHtcbiAgICAgICAgICBuZXh0RGVwZW5kZW5jaWVzLnNldChhLCB2b2lkIDApO1xuICAgICAgICAgIHJldHVybiBhLmluaXQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm8gYXRvbSBpbml0XCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgYVN0YXRlID0gcmVhZEF0b21TdGF0ZShhKTtcbiAgICAgIG5leHREZXBlbmRlbmNpZXMuc2V0KGEsIGFTdGF0ZSk7XG4gICAgICByZXR1cm4gcmV0dXJuQXRvbVZhbHVlKGFTdGF0ZSk7XG4gICAgfTtcbiAgICBsZXQgY29udHJvbGxlcjtcbiAgICBsZXQgc2V0U2VsZjtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgZ2V0IHNpZ25hbCgpIHtcbiAgICAgICAgaWYgKCFjb250cm9sbGVyKSB7XG4gICAgICAgICAgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udHJvbGxlci5zaWduYWw7XG4gICAgICB9LFxuICAgICAgZ2V0IHNldFNlbGYoKSB7XG4gICAgICAgIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIiAmJiAhaXNBY3R1YWxseVdyaXRhYmxlQXRvbShhdG9tKSkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcInNldFNlbGYgZnVuY3Rpb24gY2Fubm90IGJlIHVzZWQgd2l0aCByZWFkLW9ubHkgYXRvbVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXNldFNlbGYgJiYgaXNBY3R1YWxseVdyaXRhYmxlQXRvbShhdG9tKSkge1xuICAgICAgICAgIHNldFNlbGYgPSAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiICYmIGlzU3luYykge1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJzZXRTZWxmIGZ1bmN0aW9uIGNhbm5vdCBiZSBjYWxsZWQgaW4gc3luY1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNTeW5jKSB7XG4gICAgICAgICAgICAgIHJldHVybiB3cml0ZUF0b20oYXRvbSwgLi4uYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2V0U2VsZjtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB2YWx1ZU9yUHJvbWlzZSA9IGF0b20ucmVhZChnZXR0ZXIsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHNldEF0b21WYWx1ZU9yUHJvbWlzZShcbiAgICAgICAgYXRvbSxcbiAgICAgICAgdmFsdWVPclByb21pc2UsXG4gICAgICAgIG5leHREZXBlbmRlbmNpZXMsXG4gICAgICAgICgpID0+IGNvbnRyb2xsZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbnRyb2xsZXIuYWJvcnQoKVxuICAgICAgKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIHNldEF0b21FcnJvcihhdG9tLCBlcnJvciwgbmV4dERlcGVuZGVuY2llcyk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlzU3luYyA9IGZhbHNlO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcmVhZEF0b20gPSAoYXRvbSkgPT4gcmV0dXJuQXRvbVZhbHVlKHJlYWRBdG9tU3RhdGUoYXRvbSkpO1xuICBjb25zdCByZWNvbXB1dGVEZXBlbmRlbnRzID0gKGF0b20pID0+IHtcbiAgICBjb25zdCBnZXREZXBlbmRlbnRzID0gKGEpID0+IHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICBjb25zdCBkZXBlbmRlbnRzID0gbmV3IFNldCgoX2EgPSBtb3VudGVkTWFwLmdldChhKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnQpO1xuICAgICAgKF9iID0gcGVuZGluZ01hcC5nZXQoYSkpID09IG51bGwgPyB2b2lkIDAgOiBfYlsxXS5mb3JFYWNoKChkZXBlbmRlbnQpID0+IHtcbiAgICAgICAgZGVwZW5kZW50cy5hZGQoZGVwZW5kZW50KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGRlcGVuZGVudHM7XG4gICAgfTtcbiAgICBjb25zdCB0b3Bzb3J0ZWRBdG9tcyA9IG5ldyBBcnJheSgpO1xuICAgIGNvbnN0IG1hcmtlZEF0b21zID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBjb25zdCB2aXNpdCA9IChuKSA9PiB7XG4gICAgICBpZiAobWFya2VkQXRvbXMuaGFzKG4pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG1hcmtlZEF0b21zLmFkZChuKTtcbiAgICAgIGZvciAoY29uc3QgbSBvZiBnZXREZXBlbmRlbnRzKG4pKSB7XG4gICAgICAgIGlmIChuICE9PSBtKSB7XG4gICAgICAgICAgdmlzaXQobSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRvcHNvcnRlZEF0b21zLnB1c2gobik7XG4gICAgfTtcbiAgICB2aXNpdChhdG9tKTtcbiAgICBjb25zdCBjaGFuZ2VkQXRvbXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbYXRvbV0pO1xuICAgIGZvciAobGV0IGkgPSB0b3Bzb3J0ZWRBdG9tcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgY29uc3QgYSA9IHRvcHNvcnRlZEF0b21zW2ldO1xuICAgICAgY29uc3QgcHJldkF0b21TdGF0ZSA9IGdldEF0b21TdGF0ZShhKTtcbiAgICAgIGlmICghcHJldkF0b21TdGF0ZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGxldCBoYXNDaGFuZ2VkRGVwcyA9IGZhbHNlO1xuICAgICAgZm9yIChjb25zdCBkZXAgb2YgcHJldkF0b21TdGF0ZS5kLmtleXMoKSkge1xuICAgICAgICBpZiAoZGVwICE9PSBhICYmIGNoYW5nZWRBdG9tcy5oYXMoZGVwKSkge1xuICAgICAgICAgIGhhc0NoYW5nZWREZXBzID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGhhc0NoYW5nZWREZXBzKSB7XG4gICAgICAgIGNvbnN0IG5leHRBdG9tU3RhdGUgPSByZWFkQXRvbVN0YXRlKGEsIHRydWUpO1xuICAgICAgICBpZiAoIWlzRXF1YWxBdG9tVmFsdWUocHJldkF0b21TdGF0ZSwgbmV4dEF0b21TdGF0ZSkpIHtcbiAgICAgICAgICBjaGFuZ2VkQXRvbXMuYWRkKGEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCB3cml0ZUF0b21TdGF0ZSA9IChhdG9tLCAuLi5hcmdzKSA9PiB7XG4gICAgY29uc3QgZ2V0dGVyID0gKGEpID0+IHJldHVybkF0b21WYWx1ZShyZWFkQXRvbVN0YXRlKGEpKTtcbiAgICBjb25zdCBzZXR0ZXIgPSAoYSwgLi4uYXJnczIpID0+IHtcbiAgICAgIGNvbnN0IGlzU3luYyA9IHBlbmRpbmdTdGFjay5sZW5ndGggPiAwO1xuICAgICAgaWYgKCFpc1N5bmMpIHtcbiAgICAgICAgcGVuZGluZ1N0YWNrLnB1c2goLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW2FdKSk7XG4gICAgICB9XG4gICAgICBsZXQgcjtcbiAgICAgIGlmIChpc1NlbGZBdG9tKGF0b20sIGEpKSB7XG4gICAgICAgIGlmICghaGFzSW5pdGlhbFZhbHVlKGEpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXRvbSBub3Qgd3JpdGFibGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJldkF0b21TdGF0ZSA9IGdldEF0b21TdGF0ZShhKTtcbiAgICAgICAgY29uc3QgbmV4dEF0b21TdGF0ZSA9IHNldEF0b21WYWx1ZU9yUHJvbWlzZShhLCBhcmdzMlswXSk7XG4gICAgICAgIGlmICghaXNFcXVhbEF0b21WYWx1ZShwcmV2QXRvbVN0YXRlLCBuZXh0QXRvbVN0YXRlKSkge1xuICAgICAgICAgIHJlY29tcHV0ZURlcGVuZGVudHMoYSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHIgPSB3cml0ZUF0b21TdGF0ZShhLCAuLi5hcmdzMik7XG4gICAgICB9XG4gICAgICBpZiAoIWlzU3luYykge1xuICAgICAgICBjb25zdCBmbHVzaGVkID0gZmx1c2hQZW5kaW5nKHBlbmRpbmdTdGFjay5wb3AoKSk7XG4gICAgICAgIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgIGRldkxpc3RlbmVyc1JldjIuZm9yRWFjaChcbiAgICAgICAgICAgIChsKSA9PiBsKHsgdHlwZTogXCJhc3luYy13cml0ZVwiLCBmbHVzaGVkIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHI7XG4gICAgfTtcbiAgICBjb25zdCByZXN1bHQgPSBhdG9tLndyaXRlKGdldHRlciwgc2V0dGVyLCAuLi5hcmdzKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBjb25zdCB3cml0ZUF0b20gPSAoYXRvbSwgLi4uYXJncykgPT4ge1xuICAgIHBlbmRpbmdTdGFjay5wdXNoKC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFthdG9tXSkpO1xuICAgIGNvbnN0IHJlc3VsdCA9IHdyaXRlQXRvbVN0YXRlKGF0b20sIC4uLmFyZ3MpO1xuICAgIGNvbnN0IGZsdXNoZWQgPSBmbHVzaFBlbmRpbmcocGVuZGluZ1N0YWNrLnBvcCgpKTtcbiAgICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGRldkxpc3RlbmVyc1JldjIuZm9yRWFjaCgobCkgPT4gbCh7IHR5cGU6IFwid3JpdGVcIiwgZmx1c2hlZCB9KSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIGNvbnN0IG1vdW50QXRvbSA9IChhdG9tLCBpbml0aWFsRGVwZW5kZW50LCBvbk1vdW50UXVldWUpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgZXhpc3RpbmdNb3VudCA9IG1vdW50ZWRNYXAuZ2V0KGF0b20pO1xuICAgIGlmIChleGlzdGluZ01vdW50KSB7XG4gICAgICBpZiAoaW5pdGlhbERlcGVuZGVudCkge1xuICAgICAgICBleGlzdGluZ01vdW50LnQuYWRkKGluaXRpYWxEZXBlbmRlbnQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGV4aXN0aW5nTW91bnQ7XG4gICAgfVxuICAgIGNvbnN0IHF1ZXVlID0gb25Nb3VudFF1ZXVlIHx8IFtdO1xuICAgIChfYSA9IGdldEF0b21TdGF0ZShhdG9tKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmQuZm9yRWFjaCgoXywgYSkgPT4ge1xuICAgICAgaWYgKGEgIT09IGF0b20pIHtcbiAgICAgICAgbW91bnRBdG9tKGEsIGF0b20sIHF1ZXVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZWFkQXRvbVN0YXRlKGF0b20pO1xuICAgIGNvbnN0IG1vdW50ZWQgPSB7XG4gICAgICB0OiBuZXcgU2V0KGluaXRpYWxEZXBlbmRlbnQgJiYgW2luaXRpYWxEZXBlbmRlbnRdKSxcbiAgICAgIGw6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KClcbiAgICB9O1xuICAgIG1vdW50ZWRNYXAuc2V0KGF0b20sIG1vdW50ZWQpO1xuICAgIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgbW91bnRlZEF0b21zLmFkZChhdG9tKTtcbiAgICB9XG4gICAgaWYgKGlzQWN0dWFsbHlXcml0YWJsZUF0b20oYXRvbSkgJiYgYXRvbS5vbk1vdW50KSB7XG4gICAgICBjb25zdCB7IG9uTW91bnQgfSA9IGF0b207XG4gICAgICBxdWV1ZS5wdXNoKCgpID0+IHtcbiAgICAgICAgY29uc3Qgb25Vbm1vdW50ID0gb25Nb3VudCgoLi4uYXJncykgPT4gd3JpdGVBdG9tKGF0b20sIC4uLmFyZ3MpKTtcbiAgICAgICAgaWYgKG9uVW5tb3VudCkge1xuICAgICAgICAgIG1vdW50ZWQudSA9IG9uVW5tb3VudDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICghb25Nb3VudFF1ZXVlKSB7XG4gICAgICBxdWV1ZS5mb3JFYWNoKChmKSA9PiBmKCkpO1xuICAgIH1cbiAgICByZXR1cm4gbW91bnRlZDtcbiAgfTtcbiAgY29uc3QgY2FuVW5tb3VudEF0b20gPSAoYXRvbSwgbW91bnRlZCkgPT4gIW1vdW50ZWQubC5zaXplICYmICghbW91bnRlZC50LnNpemUgfHwgbW91bnRlZC50LnNpemUgPT09IDEgJiYgbW91bnRlZC50LmhhcyhhdG9tKSk7XG4gIGNvbnN0IHRyeVVubW91bnRBdG9tID0gKGF0b20sIG1vdW50ZWQpID0+IHtcbiAgICBpZiAoIWNhblVubW91bnRBdG9tKGF0b20sIG1vdW50ZWQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG9uVW5tb3VudCA9IG1vdW50ZWQudTtcbiAgICBpZiAob25Vbm1vdW50KSB7XG4gICAgICBvblVubW91bnQoKTtcbiAgICB9XG4gICAgbW91bnRlZE1hcC5kZWxldGUoYXRvbSk7XG4gICAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBtb3VudGVkQXRvbXMuZGVsZXRlKGF0b20pO1xuICAgIH1cbiAgICBjb25zdCBhdG9tU3RhdGUgPSBnZXRBdG9tU3RhdGUoYXRvbSk7XG4gICAgaWYgKGF0b21TdGF0ZSkge1xuICAgICAgaWYgKGhhc1Byb21pc2VBdG9tVmFsdWUoYXRvbVN0YXRlKSkge1xuICAgICAgICBjYW5jZWxQcm9taXNlKGF0b21TdGF0ZS52KTtcbiAgICAgIH1cbiAgICAgIGF0b21TdGF0ZS5kLmZvckVhY2goKF8sIGEpID0+IHtcbiAgICAgICAgaWYgKGEgIT09IGF0b20pIHtcbiAgICAgICAgICBjb25zdCBtb3VudGVkRGVwID0gbW91bnRlZE1hcC5nZXQoYSk7XG4gICAgICAgICAgaWYgKG1vdW50ZWREZXApIHtcbiAgICAgICAgICAgIG1vdW50ZWREZXAudC5kZWxldGUoYXRvbSk7XG4gICAgICAgICAgICB0cnlVbm1vdW50QXRvbShhLCBtb3VudGVkRGVwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIltCdWddIGNvdWxkIG5vdCBmaW5kIGF0b20gc3RhdGUgdG8gdW5tb3VudFwiLCBhdG9tKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IG1vdW50RGVwZW5kZW5jaWVzID0gKGF0b20sIGF0b21TdGF0ZSwgcHJldkRlcGVuZGVuY2llcykgPT4ge1xuICAgIGNvbnN0IGRlcFNldCA9IG5ldyBTZXQoYXRvbVN0YXRlLmQua2V5cygpKTtcbiAgICBjb25zdCBtYXliZVVubW91bnRBdG9tU2V0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBwcmV2RGVwZW5kZW5jaWVzID09IG51bGwgPyB2b2lkIDAgOiBwcmV2RGVwZW5kZW5jaWVzLmZvckVhY2goKF8sIGEpID0+IHtcbiAgICAgIGlmIChkZXBTZXQuaGFzKGEpKSB7XG4gICAgICAgIGRlcFNldC5kZWxldGUoYSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG1heWJlVW5tb3VudEF0b21TZXQuYWRkKGEpO1xuICAgICAgY29uc3QgbW91bnRlZCA9IG1vdW50ZWRNYXAuZ2V0KGEpO1xuICAgICAgaWYgKG1vdW50ZWQpIHtcbiAgICAgICAgbW91bnRlZC50LmRlbGV0ZShhdG9tKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBkZXBTZXQuZm9yRWFjaCgoYSkgPT4ge1xuICAgICAgbW91bnRBdG9tKGEsIGF0b20pO1xuICAgIH0pO1xuICAgIG1heWJlVW5tb3VudEF0b21TZXQuZm9yRWFjaCgoYSkgPT4ge1xuICAgICAgY29uc3QgbW91bnRlZCA9IG1vdW50ZWRNYXAuZ2V0KGEpO1xuICAgICAgaWYgKG1vdW50ZWQpIHtcbiAgICAgICAgdHJ5VW5tb3VudEF0b20oYSwgbW91bnRlZCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IGZsdXNoUGVuZGluZyA9IChwZW5kaW5nQXRvbXMpID0+IHtcbiAgICBsZXQgZmx1c2hlZDtcbiAgICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGZsdXNoZWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIH1cbiAgICBjb25zdCBwZW5kaW5nID0gW107XG4gICAgY29uc3QgY29sbGVjdFBlbmRpbmcgPSAocGVuZGluZ0F0b20pID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGlmICghcGVuZGluZ01hcC5oYXMocGVuZGluZ0F0b20pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IFtwcmV2QXRvbVN0YXRlLCBkZXBlbmRlbnRzXSA9IHBlbmRpbmdNYXAuZ2V0KHBlbmRpbmdBdG9tKTtcbiAgICAgIHBlbmRpbmdNYXAuZGVsZXRlKHBlbmRpbmdBdG9tKTtcbiAgICAgIHBlbmRpbmcucHVzaChbcGVuZGluZ0F0b20sIHByZXZBdG9tU3RhdGVdKTtcbiAgICAgIGRlcGVuZGVudHMuZm9yRWFjaChjb2xsZWN0UGVuZGluZyk7XG4gICAgICAoX2EgPSBnZXRBdG9tU3RhdGUocGVuZGluZ0F0b20pKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZC5mb3JFYWNoKChfLCBhKSA9PiBjb2xsZWN0UGVuZGluZyhhKSk7XG4gICAgfTtcbiAgICBwZW5kaW5nQXRvbXMuZm9yRWFjaChjb2xsZWN0UGVuZGluZyk7XG4gICAgcGVuZGluZy5mb3JFYWNoKChbYXRvbSwgcHJldkF0b21TdGF0ZV0pID0+IHtcbiAgICAgIGNvbnN0IGF0b21TdGF0ZSA9IGdldEF0b21TdGF0ZShhdG9tKTtcbiAgICAgIGlmICghYXRvbVN0YXRlKSB7XG4gICAgICAgIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIltCdWddIG5vIGF0b20gc3RhdGUgdG8gZmx1c2hcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGF0b21TdGF0ZSAhPT0gcHJldkF0b21TdGF0ZSkge1xuICAgICAgICBjb25zdCBtb3VudGVkID0gbW91bnRlZE1hcC5nZXQoYXRvbSk7XG4gICAgICAgIGlmIChtb3VudGVkICYmIGF0b21TdGF0ZS5kICE9PSAocHJldkF0b21TdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogcHJldkF0b21TdGF0ZS5kKSkge1xuICAgICAgICAgIG1vdW50RGVwZW5kZW5jaWVzKGF0b20sIGF0b21TdGF0ZSwgcHJldkF0b21TdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogcHJldkF0b21TdGF0ZS5kKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobW91bnRlZCAmJiAhLy8gVE9ETyBUaGlzIHNlZW1zIHByZXR0eSBoYWNreS4gSG9wZSB0byBmaXggaXQuXG4gICAgICAgIC8vIE1heWJlIHdlIGNvdWxkIGBtb3VudERlcGVuZGVuY2llc2AgaW4gYHNldEF0b21TdGF0ZWA/XG4gICAgICAgICghaGFzUHJvbWlzZUF0b21WYWx1ZShwcmV2QXRvbVN0YXRlKSAmJiAoaXNFcXVhbEF0b21WYWx1ZShwcmV2QXRvbVN0YXRlLCBhdG9tU3RhdGUpIHx8IGlzRXF1YWxBdG9tRXJyb3IocHJldkF0b21TdGF0ZSwgYXRvbVN0YXRlKSkpKSB7XG4gICAgICAgICAgbW91bnRlZC5sLmZvckVhY2goKGxpc3RlbmVyKSA9PiBsaXN0ZW5lcigpKTtcbiAgICAgICAgICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGZsdXNoZWQuYWRkKGF0b20pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgcmV0dXJuIGZsdXNoZWQ7XG4gICAgfVxuICB9O1xuICBjb25zdCBzdWJzY3JpYmVBdG9tID0gKGF0b20sIGxpc3RlbmVyKSA9PiB7XG4gICAgY29uc3QgbW91bnRlZCA9IG1vdW50QXRvbShhdG9tKTtcbiAgICBjb25zdCBmbHVzaGVkID0gZmx1c2hQZW5kaW5nKFthdG9tXSk7XG4gICAgY29uc3QgbGlzdGVuZXJzID0gbW91bnRlZC5sO1xuICAgIGxpc3RlbmVycy5hZGQobGlzdGVuZXIpO1xuICAgIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgZGV2TGlzdGVuZXJzUmV2Mi5mb3JFYWNoKFxuICAgICAgICAobCkgPT4gbCh7IHR5cGU6IFwic3ViXCIsIGZsdXNoZWQgfSlcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBsaXN0ZW5lcnMuZGVsZXRlKGxpc3RlbmVyKTtcbiAgICAgIHRyeVVubW91bnRBdG9tKGF0b20sIG1vdW50ZWQpO1xuICAgICAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGRldkxpc3RlbmVyc1JldjIuZm9yRWFjaCgobCkgPT4gbCh7IHR5cGU6IFwidW5zdWJcIiB9KSk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbiAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGdldDogcmVhZEF0b20sXG4gICAgICBzZXQ6IHdyaXRlQXRvbSxcbiAgICAgIHN1Yjogc3Vic2NyaWJlQXRvbSxcbiAgICAgIC8vIHN0b3JlIGRldiBtZXRob2RzICh0aGVzZSBhcmUgdGVudGF0aXZlIGFuZCBzdWJqZWN0IHRvIGNoYW5nZSB3aXRob3V0IG5vdGljZSlcbiAgICAgIGRldl9zdWJzY3JpYmVfc3RvcmU6IChsKSA9PiB7XG4gICAgICAgIGRldkxpc3RlbmVyc1JldjIuYWRkKGwpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgIGRldkxpc3RlbmVyc1JldjIuZGVsZXRlKGwpO1xuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGRldl9nZXRfbW91bnRlZF9hdG9tczogKCkgPT4gbW91bnRlZEF0b21zLnZhbHVlcygpLFxuICAgICAgZGV2X2dldF9hdG9tX3N0YXRlOiAoYSkgPT4gYXRvbVN0YXRlTWFwLmdldChhKSxcbiAgICAgIGRldl9nZXRfbW91bnRlZDogKGEpID0+IG1vdW50ZWRNYXAuZ2V0KGEpLFxuICAgICAgZGV2X3Jlc3RvcmVfYXRvbXM6ICh2YWx1ZXMpID0+IHtcbiAgICAgICAgcGVuZGluZ1N0YWNrLnB1c2goLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSk7XG4gICAgICAgIGZvciAoY29uc3QgW2F0b20sIHZhbHVlT3JQcm9taXNlXSBvZiB2YWx1ZXMpIHtcbiAgICAgICAgICBpZiAoaGFzSW5pdGlhbFZhbHVlKGF0b20pKSB7XG4gICAgICAgICAgICBzZXRBdG9tVmFsdWVPclByb21pc2UoYXRvbSwgdmFsdWVPclByb21pc2UpO1xuICAgICAgICAgICAgcmVjb21wdXRlRGVwZW5kZW50cyhhdG9tKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmx1c2hlZCA9IGZsdXNoUGVuZGluZyhwZW5kaW5nU3RhY2sucG9wKCkpO1xuICAgICAgICBkZXZMaXN0ZW5lcnNSZXYyLmZvckVhY2goXG4gICAgICAgICAgKGwpID0+IGwoeyB0eXBlOiBcInJlc3RvcmVcIiwgZmx1c2hlZCB9KVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBnZXQ6IHJlYWRBdG9tLFxuICAgIHNldDogd3JpdGVBdG9tLFxuICAgIHN1Yjogc3Vic2NyaWJlQXRvbVxuICB9O1xufTtcbmxldCBkZWZhdWx0U3RvcmU7XG5jb25zdCBnZXREZWZhdWx0U3RvcmUkMSA9ICgpID0+IHtcbiAgaWYgKCFkZWZhdWx0U3RvcmUpIHtcbiAgICBkZWZhdWx0U3RvcmUgPSBjcmVhdGVTdG9yZSQxKCk7XG4gICAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBnbG9iYWxUaGlzLl9fSk9UQUlfREVGQVVMVF9TVE9SRV9fIHx8IChnbG9iYWxUaGlzLl9fSk9UQUlfREVGQVVMVF9TVE9SRV9fID0gZGVmYXVsdFN0b3JlKTtcbiAgICAgIGlmIChnbG9iYWxUaGlzLl9fSk9UQUlfREVGQVVMVF9TVE9SRV9fICE9PSBkZWZhdWx0U3RvcmUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIFwiRGV0ZWN0ZWQgbXVsdGlwbGUgSm90YWkgaW5zdGFuY2VzLiBJdCBtYXkgY2F1c2UgdW5leHBlY3RlZCBiZWhhdmlvciB3aXRoIHRoZSBkZWZhdWx0IHN0b3JlLiBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL2pvdGFpL2Rpc2N1c3Npb25zLzIwNDRcIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZGVmYXVsdFN0b3JlO1xufTtcblxuU3ltYm9sKFxuICAoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIiA/IFwiQ09OVElOVUVfUFJPTUlTRVwiIDogXCJcIlxuKTtcblxuY29uc3QgY3JlYXRlU3RvcmUgPSBjcmVhdGVTdG9yZSQxO1xuY29uc3QgZ2V0RGVmYXVsdFN0b3JlID0gZ2V0RGVmYXVsdFN0b3JlJDE7XG5cbmV4cG9ydCB7IGF0b20sIGNyZWF0ZVN0b3JlLCBnZXREZWZhdWx0U3RvcmUgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jotai/esm/vanilla.mjs\n");

/***/ })

};
;